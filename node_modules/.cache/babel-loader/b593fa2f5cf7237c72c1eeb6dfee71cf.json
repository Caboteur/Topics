{"ast":null,"code":"'use strict';\n\nmodule.exports = writeFile;\nmodule.exports.sync = writeFileSync;\nmodule.exports._getTmpname = getTmpname; // for testing\n\nvar fs = require('graceful-fs');\n\nvar chain = require('slide').chain;\n\nvar MurmurHash3 = require('imurmurhash');\n\nvar extend = Object.assign || require('util')._extend;\n\nvar invocations = 0;\n\nfunction getTmpname(filename) {\n  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(++invocations)).result();\n}\n\nfunction writeFile(filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (!options) options = {};\n  fs.realpath(filename, function (_, realname) {\n    _writeFile(realname || filename, data, options, callback);\n  });\n}\n\nfunction _writeFile(filename, data, options, callback) {\n  var tmpfile = getTmpname(filename);\n\n  if (options.mode && options.chown) {\n    return thenWriteFile();\n  } else {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    return fs.stat(filename, function (err, stats) {\n      if (err || !stats) return thenWriteFile();\n      options = extend({}, options);\n\n      if (!options.mode) {\n        options.mode = stats.mode;\n      }\n\n      if (!options.chown && process.getuid) {\n        options.chown = {\n          uid: stats.uid,\n          gid: stats.gid\n        };\n      }\n\n      return thenWriteFile();\n    });\n  }\n\n  function thenWriteFile() {\n    chain([[writeFileAsync, tmpfile, data, options.mode, options.encoding || 'utf8'], options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid], options.mode && [fs, fs.chmod, tmpfile, options.mode], [fs, fs.rename, tmpfile, filename]], function (err) {\n      err ? fs.unlink(tmpfile, function () {\n        callback(err);\n      }) : callback();\n    });\n  } // doing this instead of `fs.writeFile` in order to get the ability to\n  // call `fsync`.\n\n\n  function writeFileAsync(file, data, mode, encoding, cb) {\n    fs.open(file, 'w', options.mode, function (err, fd) {\n      if (err) return cb(err);\n\n      if (Buffer.isBuffer(data)) {\n        return fs.write(fd, data, 0, data.length, 0, syncAndClose);\n      } else if (data != null) {\n        return fs.write(fd, String(data), 0, String(encoding), syncAndClose);\n      } else {\n        return syncAndClose();\n      }\n\n      function syncAndClose(err) {\n        if (err) return cb(err);\n        fs.fsync(fd, function (err) {\n          if (err) return cb(err);\n          fs.close(fd, cb);\n        });\n      }\n    });\n  }\n}\n\nfunction writeFileSync(filename, data, options) {\n  if (!options) options = {};\n\n  try {\n    filename = fs.realpathSync(filename);\n  } catch (ex) {// it's ok, it'll happen on a not yet existing file\n  }\n\n  var tmpfile = getTmpname(filename);\n\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename);\n        options = extend({}, options);\n\n        if (!options.mode) {\n          options.mode = stats.mode;\n        }\n\n        if (!options.chown && process.getuid) {\n          options.chown = {\n            uid: stats.uid,\n            gid: stats.gid\n          };\n        }\n      } catch (ex) {// ignore stat errors\n      }\n    }\n\n    var fd = fs.openSync(tmpfile, 'w', options.mode);\n\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0);\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));\n    }\n\n    fs.fsyncSync(fd);\n    fs.closeSync(fd);\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);\n    if (options.mode) fs.chmodSync(tmpfile, options.mode);\n    fs.renameSync(tmpfile, filename);\n  } catch (err) {\n    try {\n      fs.unlinkSync(tmpfile);\n    } catch (e) {}\n\n    throw err;\n  }\n}","map":{"version":3,"sources":["D:/MegaSync/proxy-server/testing/react-express-starter/node_modules/google-translate-token/node_modules/write-file-atomic/index.js"],"names":["module","exports","writeFile","sync","writeFileSync","_getTmpname","getTmpname","fs","require","chain","MurmurHash3","extend","Object","assign","_extend","invocations","filename","__filename","hash","String","process","pid","result","data","options","callback","Function","realpath","_","realname","_writeFile","tmpfile","mode","chown","thenWriteFile","stat","err","stats","getuid","uid","gid","writeFileAsync","encoding","chmod","rename","unlink","file","cb","open","fd","Buffer","isBuffer","write","length","syncAndClose","fsync","close","realpathSync","ex","statSync","openSync","writeSync","fsyncSync","closeSync","chownSync","chmodSync","renameSync","unlinkSync","e"],"mappings":"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","sourcesContent":["'use strict'\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\n\nvar fs = require('graceful-fs')\nvar chain = require('slide').chain\nvar MurmurHash3 = require('imurmurhash')\nvar extend = Object.assign || require('util')._extend\n\nvar invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction writeFile (filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options\n    options = null\n  }\n  if (!options) options = {}\n  fs.realpath(filename, function (_, realname) {\n    _writeFile(realname || filename, data, options, callback)\n  })\n}\nfunction _writeFile (filename, data, options, callback) {\n  var tmpfile = getTmpname(filename)\n\n  if (options.mode && options.chown) {\n    return thenWriteFile()\n  } else {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    return fs.stat(filename, function (err, stats) {\n      if (err || !stats) return thenWriteFile()\n\n      options = extend({}, options)\n      if (!options.mode) {\n        options.mode = stats.mode\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n      return thenWriteFile()\n    })\n  }\n\n  function thenWriteFile () {\n    chain([\n      [writeFileAsync, tmpfile, data, options.mode, options.encoding || 'utf8'],\n      options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid],\n      options.mode && [fs, fs.chmod, tmpfile, options.mode],\n      [fs, fs.rename, tmpfile, filename]\n    ], function (err) {\n      err ? fs.unlink(tmpfile, function () { callback(err) })\n        : callback()\n    })\n  }\n\n  // doing this instead of `fs.writeFile` in order to get the ability to\n  // call `fsync`.\n  function writeFileAsync (file, data, mode, encoding, cb) {\n    fs.open(file, 'w', options.mode, function (err, fd) {\n      if (err) return cb(err)\n      if (Buffer.isBuffer(data)) {\n        return fs.write(fd, data, 0, data.length, 0, syncAndClose)\n      } else if (data != null) {\n        return fs.write(fd, String(data), 0, String(encoding), syncAndClose)\n      } else {\n        return syncAndClose()\n      }\n      function syncAndClose (err) {\n        if (err) return cb(err)\n        fs.fsync(fd, function (err) {\n          if (err) return cb(err)\n          fs.close(fd, cb)\n        })\n      }\n    })\n  }\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (!options) options = {}\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  var tmpfile = getTmpname(filename)\n\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename)\n        options = extend({}, options)\n        if (!options.mode) {\n          options.mode = stats.mode\n        }\n        if (!options.chown && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      } catch (ex) {\n        // ignore stat errors\n      }\n    }\n\n    var fd = fs.openSync(tmpfile, 'w', options.mode)\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    fs.fsyncSync(fd)\n    fs.closeSync(fd)\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n    if (options.mode) fs.chmodSync(tmpfile, options.mode)\n    fs.renameSync(tmpfile, filename)\n  } catch (err) {\n    try { fs.unlinkSync(tmpfile) } catch (e) {}\n    throw err\n  }\n}\n"]},"metadata":{},"sourceType":"script"}