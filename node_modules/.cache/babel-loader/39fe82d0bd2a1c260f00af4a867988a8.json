{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _require = require('url'),\n    URL = _require.URL;\n\nvar is = require('@sindresorhus/is');\n\nvar knownHookEvents = require('./known-hook-events');\n\nvar merge = function merge(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {\n    var source = _sources[_i];\n\n    for (var _i2 = 0, _Object$entries = Object.entries(source); _i2 < _Object$entries.length; _i2++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n          key = _Object$entries$_i[0],\n          sourceValue = _Object$entries$_i[1];\n\n      if (is.undefined(sourceValue)) {\n        continue;\n      }\n\n      var targetValue = target[key];\n\n      if (is.urlInstance(targetValue) && (is.urlInstance(sourceValue) || is.string(sourceValue))) {\n        target[key] = new URL(sourceValue, targetValue);\n      } else if (is.plainObject(sourceValue)) {\n        if (is.plainObject(targetValue)) {\n          target[key] = merge({}, targetValue, sourceValue);\n        } else {\n          target[key] = merge({}, sourceValue);\n        }\n      } else if (is.array(sourceValue)) {\n        target[key] = merge([], sourceValue);\n      } else {\n        target[key] = sourceValue;\n      }\n    }\n  }\n\n  return target;\n};\n\nvar mergeOptions = function mergeOptions() {\n  for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    sources[_key2] = arguments[_key2];\n  }\n\n  sources = sources.map(function (source) {\n    return source || {};\n  });\n  var merged = merge.apply(void 0, [{}].concat(_toConsumableArray(sources)));\n  var hooks = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = knownHookEvents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var hook = _step.value;\n      hooks[hook] = [];\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = sources[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var source = _step2.value;\n\n      if (source.hooks) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = knownHookEvents[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _hook = _step3.value;\n            hooks[_hook] = hooks[_hook].concat(source.hooks[_hook]);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  merged.hooks = hooks;\n  return merged;\n};\n\nvar mergeInstances = function mergeInstances(instances, methods) {\n  var handlers = instances.map(function (instance) {\n    return instance.defaults.handler;\n  });\n  var size = instances.length - 1;\n  return {\n    methods: methods,\n    options: mergeOptions.apply(void 0, _toConsumableArray(instances.map(function (instance) {\n      return instance.defaults.options;\n    }))),\n    handler: function handler(options, next) {\n      var iteration = -1;\n\n      var iterate = function iterate(options) {\n        return handlers[++iteration](options, iteration === size ? next : iterate);\n      };\n\n      return iterate(options);\n    }\n  };\n};\n\nmodule.exports = merge;\nmodule.exports.options = mergeOptions;\nmodule.exports.instances = mergeInstances;","map":{"version":3,"sources":["D:/MegaSync/proxy-server/testing/react-express-starter/node_modules/@vitalets/google-translate-api/node_modules/got/source/merge.js"],"names":["require","URL","is","knownHookEvents","merge","target","sources","source","Object","entries","key","sourceValue","undefined","targetValue","urlInstance","string","plainObject","array","mergeOptions","map","merged","hooks","hook","concat","mergeInstances","instances","methods","handlers","instance","defaults","handler","size","length","options","next","iteration","iterate","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst {URL} = require('url');\nconst is = require('@sindresorhus/is');\nconst knownHookEvents = require('./known-hook-events');\n\nconst merge = (target, ...sources) => {\n\tfor (const source of sources) {\n\t\tfor (const [key, sourceValue] of Object.entries(source)) {\n\t\t\tif (is.undefined(sourceValue)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst targetValue = target[key];\n\t\t\tif (is.urlInstance(targetValue) && (is.urlInstance(sourceValue) || is.string(sourceValue))) {\n\t\t\t\ttarget[key] = new URL(sourceValue, targetValue);\n\t\t\t} else if (is.plainObject(sourceValue)) {\n\t\t\t\tif (is.plainObject(targetValue)) {\n\t\t\t\t\ttarget[key] = merge({}, targetValue, sourceValue);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = merge({}, sourceValue);\n\t\t\t\t}\n\t\t\t} else if (is.array(sourceValue)) {\n\t\t\t\ttarget[key] = merge([], sourceValue);\n\t\t\t} else {\n\t\t\t\ttarget[key] = sourceValue;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn target;\n};\n\nconst mergeOptions = (...sources) => {\n\tsources = sources.map(source => source || {});\n\tconst merged = merge({}, ...sources);\n\n\tconst hooks = {};\n\tfor (const hook of knownHookEvents) {\n\t\thooks[hook] = [];\n\t}\n\n\tfor (const source of sources) {\n\t\tif (source.hooks) {\n\t\t\tfor (const hook of knownHookEvents) {\n\t\t\t\thooks[hook] = hooks[hook].concat(source.hooks[hook]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmerged.hooks = hooks;\n\n\treturn merged;\n};\n\nconst mergeInstances = (instances, methods) => {\n\tconst handlers = instances.map(instance => instance.defaults.handler);\n\tconst size = instances.length - 1;\n\n\treturn {\n\t\tmethods,\n\t\toptions: mergeOptions(...instances.map(instance => instance.defaults.options)),\n\t\thandler: (options, next) => {\n\t\t\tlet iteration = -1;\n\t\t\tconst iterate = options => handlers[++iteration](options, iteration === size ? next : iterate);\n\n\t\t\treturn iterate(options);\n\t\t}\n\t};\n};\n\nmodule.exports = merge;\nmodule.exports.options = mergeOptions;\nmodule.exports.instances = mergeInstances;\n"]},"metadata":{},"sourceType":"script"}