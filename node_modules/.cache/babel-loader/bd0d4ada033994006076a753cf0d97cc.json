{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _require = require('url'),\n    URL = _require.URL; // TODO: Use the `URL` global when targeting Node.js 10\n\n\nvar util = require('util');\n\nvar EventEmitter = require('events');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar urlLib = require('url');\n\nvar CacheableRequest = require('cacheable-request');\n\nvar toReadableStream = require('to-readable-stream');\n\nvar is = require('@sindresorhus/is');\n\nvar timer = require('@szmarczak/http-timer');\n\nvar timedOut = require('./utils/timed-out');\n\nvar getBodySize = require('./utils/get-body-size');\n\nvar getResponse = require('./get-response');\n\nvar progress = require('./progress');\n\nvar _require2 = require('./errors'),\n    CacheError = _require2.CacheError,\n    UnsupportedProtocolError = _require2.UnsupportedProtocolError,\n    MaxRedirectsError = _require2.MaxRedirectsError,\n    RequestError = _require2.RequestError,\n    TimeoutError = _require2.TimeoutError;\n\nvar urlToOptions = require('./utils/url-to-options');\n\nvar getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);\nvar allMethodRedirectCodes = new Set([300, 303, 307, 308]);\n\nmodule.exports = function (options, input) {\n  var emitter = new EventEmitter();\n  var redirects = [];\n  var currentRequest;\n  var requestUrl;\n  var redirectString;\n  var uploadBodySize;\n  var retryCount = 0;\n  var shouldAbort = false;\n  var setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;\n  var getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;\n  var agents = is.object(options.agent) ? options.agent : null;\n\n  var emitError =\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(error) {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, hook;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 4;\n              _iterator = options.hooks.beforeError[Symbol.iterator]();\n\n            case 6:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 14;\n                break;\n              }\n\n              hook = _step.value;\n              _context.next = 10;\n              return hook(error);\n\n            case 10:\n              error = _context.sent;\n\n            case 11:\n              _iteratorNormalCompletion = true;\n              _context.next = 6;\n              break;\n\n            case 14:\n              _context.next = 20;\n              break;\n\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 20:\n              _context.prev = 20;\n              _context.prev = 21;\n\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n\n            case 23:\n              _context.prev = 23;\n\n              if (!_didIteratorError) {\n                _context.next = 26;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 26:\n              return _context.finish(23);\n\n            case 27:\n              return _context.finish(20);\n\n            case 28:\n              emitter.emit('error', error);\n              _context.next = 34;\n              break;\n\n            case 31:\n              _context.prev = 31;\n              _context.t1 = _context[\"catch\"](0);\n              emitter.emit('error', _context.t1);\n\n            case 34:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 31], [4, 16, 20, 28], [21,, 23, 27]]);\n    }));\n\n    return function emitError(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  var get =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(options) {\n      var currentUrl, fn, protocolName, r, electron, cookieString, timings, handleResponse, handleRequest, cacheableRequest, cacheRequest;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              currentUrl = redirectString || requestUrl;\n\n              if (!(options.protocol !== 'http:' && options.protocol !== 'https:')) {\n                _context3.next = 3;\n                break;\n              }\n\n              throw new UnsupportedProtocolError(options);\n\n            case 3:\n              decodeURI(currentUrl);\n\n              if (is.function(options.request)) {\n                fn = {\n                  request: options.request\n                };\n              } else {\n                fn = options.protocol === 'https:' ? https : http;\n              }\n\n              if (agents) {\n                protocolName = options.protocol === 'https:' ? 'https' : 'http';\n                options.agent = agents[protocolName] || options.agent;\n              }\n              /* istanbul ignore next: electron.net is broken */\n\n\n              if (options.useElectronNet && process.versions.electron) {\n                r = {\n                  x: require\n                }['yx'.slice(1)]; // Trick webpack\n\n                electron = r('electron');\n                fn = electron.net || electron.remote.net;\n              }\n\n              if (!options.cookieJar) {\n                _context3.next = 12;\n                break;\n              }\n\n              _context3.next = 10;\n              return getCookieString(currentUrl, {});\n\n            case 10:\n              cookieString = _context3.sent;\n\n              if (is.nonEmptyString(cookieString)) {\n                options.headers.cookie = cookieString;\n              }\n\n            case 12:\n              handleResponse =\n              /*#__PURE__*/\n              function () {\n                var _ref3 = _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee2(response) {\n                  var _response, statusCode, rawCookies, redirectBuffer, redirectURL, redirectOptions, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, hook;\n\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.prev = 0;\n\n                          /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n                          if (options.useElectronNet) {\n                            response = new Proxy(response, {\n                              get: function get(target, name) {\n                                if (name === 'trailers' || name === 'rawTrailers') {\n                                  return [];\n                                }\n\n                                var value = target[name];\n                                return is.function(value) ? value.bind(target) : value;\n                              }\n                            });\n                          }\n\n                          _response = response, statusCode = _response.statusCode;\n                          response.url = currentUrl;\n                          response.requestUrl = requestUrl;\n                          response.retryCount = retryCount;\n                          response.timings = timings;\n                          response.redirectUrls = redirects;\n                          response.request = {\n                            gotOptions: options\n                          };\n                          rawCookies = response.headers['set-cookie'];\n\n                          if (!(options.cookieJar && rawCookies)) {\n                            _context2.next = 13;\n                            break;\n                          }\n\n                          _context2.next = 13;\n                          return Promise.all(rawCookies.map(function (rawCookie) {\n                            return setCookie(rawCookie, response.url);\n                          }));\n\n                        case 13:\n                          if (!(options.followRedirect && 'location' in response.headers)) {\n                            _context2.next = 54;\n                            break;\n                          }\n\n                          if (!(allMethodRedirectCodes.has(statusCode) || getMethodRedirectCodes.has(statusCode) && (options.method === 'GET' || options.method === 'HEAD'))) {\n                            _context2.next = 54;\n                            break;\n                          }\n\n                          response.resume(); // We're being redirected, we don't care about the response.\n\n                          if (statusCode === 303) {\n                            // Server responded with \"see other\", indicating that the resource exists at another location,\n                            // and the client should request it from that location via GET or HEAD.\n                            options.method = 'GET';\n                          }\n\n                          if (!(redirects.length >= 10)) {\n                            _context2.next = 19;\n                            break;\n                          }\n\n                          throw new MaxRedirectsError(statusCode, redirects, options);\n\n                        case 19:\n                          // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n                          redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                          redirectURL = new URL(redirectBuffer, currentUrl);\n                          redirectString = redirectURL.toString();\n                          redirects.push(redirectString);\n                          redirectOptions = _objectSpread({}, options, {}, urlToOptions(redirectURL));\n                          _iteratorNormalCompletion2 = true;\n                          _didIteratorError2 = false;\n                          _iteratorError2 = undefined;\n                          _context2.prev = 27;\n                          _iterator2 = options.hooks.beforeRedirect[Symbol.iterator]();\n\n                        case 29:\n                          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                            _context2.next = 36;\n                            break;\n                          }\n\n                          hook = _step2.value;\n                          _context2.next = 33;\n                          return hook(redirectOptions);\n\n                        case 33:\n                          _iteratorNormalCompletion2 = true;\n                          _context2.next = 29;\n                          break;\n\n                        case 36:\n                          _context2.next = 42;\n                          break;\n\n                        case 38:\n                          _context2.prev = 38;\n                          _context2.t0 = _context2[\"catch\"](27);\n                          _didIteratorError2 = true;\n                          _iteratorError2 = _context2.t0;\n\n                        case 42:\n                          _context2.prev = 42;\n                          _context2.prev = 43;\n\n                          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                            _iterator2.return();\n                          }\n\n                        case 45:\n                          _context2.prev = 45;\n\n                          if (!_didIteratorError2) {\n                            _context2.next = 48;\n                            break;\n                          }\n\n                          throw _iteratorError2;\n\n                        case 48:\n                          return _context2.finish(45);\n\n                        case 49:\n                          return _context2.finish(42);\n\n                        case 50:\n                          emitter.emit('redirect', response, redirectOptions);\n                          _context2.next = 53;\n                          return get(redirectOptions);\n\n                        case 53:\n                          return _context2.abrupt(\"return\");\n\n                        case 54:\n                          getResponse(response, options, emitter);\n                          _context2.next = 60;\n                          break;\n\n                        case 57:\n                          _context2.prev = 57;\n                          _context2.t1 = _context2[\"catch\"](0);\n                          emitError(_context2.t1);\n\n                        case 60:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, null, [[0, 57], [27, 38, 42, 50], [43,, 45, 49]]);\n                }));\n\n                return function handleResponse(_x3) {\n                  return _ref3.apply(this, arguments);\n                };\n              }();\n\n              handleRequest = function handleRequest(request) {\n                if (shouldAbort) {\n                  request.once('error', function () {});\n                  request.abort();\n                  return;\n                }\n\n                currentRequest = request;\n                request.once('error', function (error) {\n                  if (request.aborted) {\n                    return;\n                  }\n\n                  if (error instanceof timedOut.TimeoutError) {\n                    error = new TimeoutError(error, options);\n                  } else {\n                    error = new RequestError(error, options);\n                  }\n\n                  if (emitter.retry(error) === false) {\n                    emitError(error);\n                  }\n                });\n                timings = timer(request);\n                progress.upload(request, emitter, uploadBodySize);\n\n                if (options.gotTimeout) {\n                  timedOut(request, options.gotTimeout, options);\n                }\n\n                emitter.emit('request', request);\n\n                var uploadComplete = function uploadComplete() {\n                  request.emit('upload-complete');\n                };\n\n                try {\n                  if (is.nodeStream(options.body)) {\n                    options.body.once('end', uploadComplete);\n                    options.body.pipe(request);\n                    options.body = undefined;\n                  } else if (options.body) {\n                    request.end(options.body, uploadComplete);\n                  } else if (input && (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH')) {\n                    input.once('end', uploadComplete);\n                    input.pipe(request);\n                  } else {\n                    request.end(uploadComplete);\n                  }\n                } catch (error) {\n                  emitError(new RequestError(error, options));\n                }\n              };\n\n              if (options.cache) {\n                cacheableRequest = new CacheableRequest(fn.request, options.cache);\n                cacheRequest = cacheableRequest(options, handleResponse);\n                cacheRequest.once('error', function (error) {\n                  if (error instanceof CacheableRequest.RequestError) {\n                    emitError(new RequestError(error, options));\n                  } else {\n                    emitError(new CacheError(error, options));\n                  }\n                });\n                cacheRequest.once('request', handleRequest);\n              } else {\n                // Catches errors thrown by calling fn.request(...)\n                try {\n                  handleRequest(fn.request(options, handleResponse));\n                } catch (error) {\n                  emitError(new RequestError(error, options));\n                }\n              }\n\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function get(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  emitter.retry = function (error) {\n    var backoff;\n\n    try {\n      backoff = options.retry.retries(++retryCount, error);\n    } catch (error2) {\n      emitError(error2);\n      return;\n    }\n\n    if (backoff) {\n      var retry =\n      /*#__PURE__*/\n      function () {\n        var _ref4 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee4(options) {\n          var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, hook;\n\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.prev = 0;\n                  _iteratorNormalCompletion3 = true;\n                  _didIteratorError3 = false;\n                  _iteratorError3 = undefined;\n                  _context4.prev = 4;\n                  _iterator3 = options.hooks.beforeRetry[Symbol.iterator]();\n\n                case 6:\n                  if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                    _context4.next = 13;\n                    break;\n                  }\n\n                  hook = _step3.value;\n                  _context4.next = 10;\n                  return hook(options, error, retryCount);\n\n                case 10:\n                  _iteratorNormalCompletion3 = true;\n                  _context4.next = 6;\n                  break;\n\n                case 13:\n                  _context4.next = 19;\n                  break;\n\n                case 15:\n                  _context4.prev = 15;\n                  _context4.t0 = _context4[\"catch\"](4);\n                  _didIteratorError3 = true;\n                  _iteratorError3 = _context4.t0;\n\n                case 19:\n                  _context4.prev = 19;\n                  _context4.prev = 20;\n\n                  if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                    _iterator3.return();\n                  }\n\n                case 22:\n                  _context4.prev = 22;\n\n                  if (!_didIteratorError3) {\n                    _context4.next = 25;\n                    break;\n                  }\n\n                  throw _iteratorError3;\n\n                case 25:\n                  return _context4.finish(22);\n\n                case 26:\n                  return _context4.finish(19);\n\n                case 27:\n                  _context4.next = 29;\n                  return get(options);\n\n                case 29:\n                  _context4.next = 34;\n                  break;\n\n                case 31:\n                  _context4.prev = 31;\n                  _context4.t1 = _context4[\"catch\"](0);\n                  emitError(_context4.t1);\n\n                case 34:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, null, [[0, 31], [4, 15, 19, 27], [20,, 22, 26]]);\n        }));\n\n        return function retry(_x4) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n\n      setTimeout(retry, backoff, _objectSpread({}, options, {\n        forceRefresh: true\n      }));\n      return true;\n    }\n\n    return false;\n  };\n\n  emitter.abort = function () {\n    if (currentRequest) {\n      currentRequest.once('error', function () {});\n      currentRequest.abort();\n    } else {\n      shouldAbort = true;\n    }\n  };\n\n  setImmediate(\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5() {\n    var body, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, hook;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            // Convert buffer to stream to receive upload progress events (#322)\n            body = options.body;\n\n            if (!is.buffer(body)) {\n              _context5.next = 7;\n              break;\n            }\n\n            options.body = toReadableStream(body);\n            uploadBodySize = body.length;\n            _context5.next = 10;\n            break;\n\n          case 7:\n            _context5.next = 9;\n            return getBodySize(options);\n\n          case 9:\n            uploadBodySize = _context5.sent;\n\n          case 10:\n            if (is.undefined(options.headers['content-length']) && is.undefined(options.headers['transfer-encoding'])) {\n              if ((uploadBodySize > 0 || options.method === 'PUT') && !is.null(uploadBodySize)) {\n                options.headers['content-length'] = uploadBodySize;\n              }\n            }\n\n            _iteratorNormalCompletion4 = true;\n            _didIteratorError4 = false;\n            _iteratorError4 = undefined;\n            _context5.prev = 14;\n            _iterator4 = options.hooks.beforeRequest[Symbol.iterator]();\n\n          case 16:\n            if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n              _context5.next = 23;\n              break;\n            }\n\n            hook = _step4.value;\n            _context5.next = 20;\n            return hook(options);\n\n          case 20:\n            _iteratorNormalCompletion4 = true;\n            _context5.next = 16;\n            break;\n\n          case 23:\n            _context5.next = 29;\n            break;\n\n          case 25:\n            _context5.prev = 25;\n            _context5.t0 = _context5[\"catch\"](14);\n            _didIteratorError4 = true;\n            _iteratorError4 = _context5.t0;\n\n          case 29:\n            _context5.prev = 29;\n            _context5.prev = 30;\n\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n\n          case 32:\n            _context5.prev = 32;\n\n            if (!_didIteratorError4) {\n              _context5.next = 35;\n              break;\n            }\n\n            throw _iteratorError4;\n\n          case 35:\n            return _context5.finish(32);\n\n          case 36:\n            return _context5.finish(29);\n\n          case 37:\n            requestUrl = options.href || new URL(options.path, urlLib.format(options)).toString();\n            _context5.next = 40;\n            return get(options);\n\n          case 40:\n            _context5.next = 45;\n            break;\n\n          case 42:\n            _context5.prev = 42;\n            _context5.t1 = _context5[\"catch\"](0);\n            emitError(_context5.t1);\n\n          case 45:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[0, 42], [14, 25, 29, 37], [30,, 32, 36]]);\n  })));\n  return emitter;\n};","map":{"version":3,"sources":["D:/MegaSync/proxy-server/testing/react-express-starter/node_modules/@vitalets/google-translate-api/node_modules/got/source/request-as-event-emitter.js"],"names":["require","URL","util","EventEmitter","http","https","urlLib","CacheableRequest","toReadableStream","is","timer","timedOut","getBodySize","getResponse","progress","CacheError","UnsupportedProtocolError","MaxRedirectsError","RequestError","TimeoutError","urlToOptions","getMethodRedirectCodes","Set","allMethodRedirectCodes","module","exports","options","input","emitter","redirects","currentRequest","requestUrl","redirectString","uploadBodySize","retryCount","shouldAbort","setCookie","cookieJar","promisify","bind","getCookieString","agents","object","agent","emitError","error","hooks","beforeError","hook","emit","get","currentUrl","protocol","decodeURI","function","request","fn","protocolName","useElectronNet","process","versions","electron","r","x","slice","net","remote","cookieString","nonEmptyString","headers","cookie","handleResponse","response","Proxy","target","name","value","statusCode","url","timings","redirectUrls","gotOptions","rawCookies","Promise","all","map","rawCookie","followRedirect","has","method","resume","length","redirectBuffer","Buffer","from","location","toString","redirectURL","push","redirectOptions","beforeRedirect","handleRequest","once","abort","aborted","retry","upload","gotTimeout","uploadComplete","nodeStream","body","pipe","undefined","end","cache","cacheableRequest","cacheRequest","backoff","retries","error2","beforeRetry","setTimeout","forceRefresh","setImmediate","buffer","null","beforeRequest","href","path","format"],"mappings":"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","sourcesContent":["'use strict';\nconst {URL} = require('url'); // TODO: Use the `URL` global when targeting Node.js 10\nconst util = require('util');\nconst EventEmitter = require('events');\nconst http = require('http');\nconst https = require('https');\nconst urlLib = require('url');\nconst CacheableRequest = require('cacheable-request');\nconst toReadableStream = require('to-readable-stream');\nconst is = require('@sindresorhus/is');\nconst timer = require('@szmarczak/http-timer');\nconst timedOut = require('./utils/timed-out');\nconst getBodySize = require('./utils/get-body-size');\nconst getResponse = require('./get-response');\nconst progress = require('./progress');\nconst {CacheError, UnsupportedProtocolError, MaxRedirectsError, RequestError, TimeoutError} = require('./errors');\nconst urlToOptions = require('./utils/url-to-options');\n\nconst getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);\nconst allMethodRedirectCodes = new Set([300, 303, 307, 308]);\n\nmodule.exports = (options, input) => {\n\tconst emitter = new EventEmitter();\n\tconst redirects = [];\n\tlet currentRequest;\n\tlet requestUrl;\n\tlet redirectString;\n\tlet uploadBodySize;\n\tlet retryCount = 0;\n\tlet shouldAbort = false;\n\n\tconst setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;\n\tconst getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;\n\tconst agents = is.object(options.agent) ? options.agent : null;\n\n\tconst emitError = async error => {\n\t\ttry {\n\t\t\tfor (const hook of options.hooks.beforeError) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\terror = await hook(error);\n\t\t\t}\n\n\t\t\temitter.emit('error', error);\n\t\t} catch (error2) {\n\t\t\temitter.emit('error', error2);\n\t\t}\n\t};\n\n\tconst get = async options => {\n\t\tconst currentUrl = redirectString || requestUrl;\n\n\t\tif (options.protocol !== 'http:' && options.protocol !== 'https:') {\n\t\t\tthrow new UnsupportedProtocolError(options);\n\t\t}\n\n\t\tdecodeURI(currentUrl);\n\n\t\tlet fn;\n\t\tif (is.function(options.request)) {\n\t\t\tfn = {request: options.request};\n\t\t} else {\n\t\t\tfn = options.protocol === 'https:' ? https : http;\n\t\t}\n\n\t\tif (agents) {\n\t\t\tconst protocolName = options.protocol === 'https:' ? 'https' : 'http';\n\t\t\toptions.agent = agents[protocolName] || options.agent;\n\t\t}\n\n\t\t/* istanbul ignore next: electron.net is broken */\n\t\tif (options.useElectronNet && process.versions.electron) {\n\t\t\tconst r = ({x: require})['yx'.slice(1)]; // Trick webpack\n\t\t\tconst electron = r('electron');\n\t\t\tfn = electron.net || electron.remote.net;\n\t\t}\n\n\t\tif (options.cookieJar) {\n\t\t\tconst cookieString = await getCookieString(currentUrl, {});\n\n\t\t\tif (is.nonEmptyString(cookieString)) {\n\t\t\t\toptions.headers.cookie = cookieString;\n\t\t\t}\n\t\t}\n\n\t\tlet timings;\n\t\tconst handleResponse = async response => {\n\t\t\ttry {\n\t\t\t\t/* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n\t\t\t\tif (options.useElectronNet) {\n\t\t\t\t\tresponse = new Proxy(response, {\n\t\t\t\t\t\tget: (target, name) => {\n\t\t\t\t\t\t\tif (name === 'trailers' || name === 'rawTrailers') {\n\t\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst value = target[name];\n\t\t\t\t\t\t\treturn is.function(value) ? value.bind(target) : value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst {statusCode} = response;\n\t\t\t\tresponse.url = currentUrl;\n\t\t\t\tresponse.requestUrl = requestUrl;\n\t\t\t\tresponse.retryCount = retryCount;\n\t\t\t\tresponse.timings = timings;\n\t\t\t\tresponse.redirectUrls = redirects;\n\t\t\t\tresponse.request = {\n\t\t\t\t\tgotOptions: options\n\t\t\t\t};\n\n\t\t\t\tconst rawCookies = response.headers['set-cookie'];\n\t\t\t\tif (options.cookieJar && rawCookies) {\n\t\t\t\t\tawait Promise.all(rawCookies.map(rawCookie => setCookie(rawCookie, response.url)));\n\t\t\t\t}\n\n\t\t\t\tif (options.followRedirect && 'location' in response.headers) {\n\t\t\t\t\tif (allMethodRedirectCodes.has(statusCode) || (getMethodRedirectCodes.has(statusCode) && (options.method === 'GET' || options.method === 'HEAD'))) {\n\t\t\t\t\t\tresponse.resume(); // We're being redirected, we don't care about the response.\n\n\t\t\t\t\t\tif (statusCode === 303) {\n\t\t\t\t\t\t\t// Server responded with \"see other\", indicating that the resource exists at another location,\n\t\t\t\t\t\t\t// and the client should request it from that location via GET or HEAD.\n\t\t\t\t\t\t\toptions.method = 'GET';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (redirects.length >= 10) {\n\t\t\t\t\t\t\tthrow new MaxRedirectsError(statusCode, redirects, options);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n\t\t\t\t\t\tconst redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n\t\t\t\t\t\tconst redirectURL = new URL(redirectBuffer, currentUrl);\n\t\t\t\t\t\tredirectString = redirectURL.toString();\n\n\t\t\t\t\t\tredirects.push(redirectString);\n\n\t\t\t\t\t\tconst redirectOptions = {\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t...urlToOptions(redirectURL)\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor (const hook of options.hooks.beforeRedirect) {\n\t\t\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\t\t\tawait hook(redirectOptions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\temitter.emit('redirect', response, redirectOptions);\n\n\t\t\t\t\t\tawait get(redirectOptions);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgetResponse(response, options, emitter);\n\t\t\t} catch (error) {\n\t\t\t\temitError(error);\n\t\t\t}\n\t\t};\n\n\t\tconst handleRequest = request => {\n\t\t\tif (shouldAbort) {\n\t\t\t\trequest.once('error', () => {});\n\t\t\t\trequest.abort();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcurrentRequest = request;\n\n\t\t\trequest.once('error', error => {\n\t\t\t\tif (request.aborted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (error instanceof timedOut.TimeoutError) {\n\t\t\t\t\terror = new TimeoutError(error, options);\n\t\t\t\t} else {\n\t\t\t\t\terror = new RequestError(error, options);\n\t\t\t\t}\n\n\t\t\t\tif (emitter.retry(error) === false) {\n\t\t\t\t\temitError(error);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\ttimings = timer(request);\n\n\t\t\tprogress.upload(request, emitter, uploadBodySize);\n\n\t\t\tif (options.gotTimeout) {\n\t\t\t\ttimedOut(request, options.gotTimeout, options);\n\t\t\t}\n\n\t\t\temitter.emit('request', request);\n\n\t\t\tconst uploadComplete = () => {\n\t\t\t\trequest.emit('upload-complete');\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (is.nodeStream(options.body)) {\n\t\t\t\t\toptions.body.once('end', uploadComplete);\n\t\t\t\t\toptions.body.pipe(request);\n\t\t\t\t\toptions.body = undefined;\n\t\t\t\t} else if (options.body) {\n\t\t\t\t\trequest.end(options.body, uploadComplete);\n\t\t\t\t} else if (input && (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH')) {\n\t\t\t\t\tinput.once('end', uploadComplete);\n\t\t\t\t\tinput.pipe(request);\n\t\t\t\t} else {\n\t\t\t\t\trequest.end(uploadComplete);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\temitError(new RequestError(error, options));\n\t\t\t}\n\t\t};\n\n\t\tif (options.cache) {\n\t\t\tconst cacheableRequest = new CacheableRequest(fn.request, options.cache);\n\t\t\tconst cacheRequest = cacheableRequest(options, handleResponse);\n\n\t\t\tcacheRequest.once('error', error => {\n\t\t\t\tif (error instanceof CacheableRequest.RequestError) {\n\t\t\t\t\temitError(new RequestError(error, options));\n\t\t\t\t} else {\n\t\t\t\t\temitError(new CacheError(error, options));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcacheRequest.once('request', handleRequest);\n\t\t} else {\n\t\t\t// Catches errors thrown by calling fn.request(...)\n\t\t\ttry {\n\t\t\t\thandleRequest(fn.request(options, handleResponse));\n\t\t\t} catch (error) {\n\t\t\t\temitError(new RequestError(error, options));\n\t\t\t}\n\t\t}\n\t};\n\n\temitter.retry = error => {\n\t\tlet backoff;\n\n\t\ttry {\n\t\t\tbackoff = options.retry.retries(++retryCount, error);\n\t\t} catch (error2) {\n\t\t\temitError(error2);\n\t\t\treturn;\n\t\t}\n\n\t\tif (backoff) {\n\t\t\tconst retry = async options => {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const hook of options.hooks.beforeRetry) {\n\t\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\t\tawait hook(options, error, retryCount);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait get(options);\n\t\t\t\t} catch (error) {\n\t\t\t\t\temitError(error);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tsetTimeout(retry, backoff, {...options, forceRefresh: true});\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\temitter.abort = () => {\n\t\tif (currentRequest) {\n\t\t\tcurrentRequest.once('error', () => {});\n\t\t\tcurrentRequest.abort();\n\t\t} else {\n\t\t\tshouldAbort = true;\n\t\t}\n\t};\n\n\tsetImmediate(async () => {\n\t\ttry {\n\t\t\t// Convert buffer to stream to receive upload progress events (#322)\n\t\t\tconst {body} = options;\n\t\t\tif (is.buffer(body)) {\n\t\t\t\toptions.body = toReadableStream(body);\n\t\t\t\tuploadBodySize = body.length;\n\t\t\t} else {\n\t\t\t\tuploadBodySize = await getBodySize(options);\n\t\t\t}\n\n\t\t\tif (is.undefined(options.headers['content-length']) && is.undefined(options.headers['transfer-encoding'])) {\n\t\t\t\tif ((uploadBodySize > 0 || options.method === 'PUT') && !is.null(uploadBodySize)) {\n\t\t\t\t\toptions.headers['content-length'] = uploadBodySize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const hook of options.hooks.beforeRequest) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tawait hook(options);\n\t\t\t}\n\n\t\t\trequestUrl = options.href || (new URL(options.path, urlLib.format(options))).toString();\n\n\t\t\tawait get(options);\n\t\t} catch (error) {\n\t\t\temitError(error);\n\t\t}\n\t});\n\n\treturn emitter;\n};\n"]},"metadata":{},"sourceType":"script"}