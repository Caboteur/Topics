{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _objectSpread = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _slicedToArray = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar EventEmitter = require('events');\n\nvar getStream = require('get-stream');\n\nvar is = require('@sindresorhus/is');\n\nvar PCancelable = require('p-cancelable');\n\nvar requestAsEventEmitter = require('./request-as-event-emitter');\n\nvar _require = require('./errors'),\n    HTTPError = _require.HTTPError,\n    ParseError = _require.ParseError,\n    ReadError = _require.ReadError;\n\nvar _require2 = require('./merge'),\n    mergeOptions = _require2.options;\n\nvar _require3 = require('./normalize-arguments'),\n    reNormalize = _require3.reNormalize;\n\nvar asPromise = function asPromise(options) {\n  var proxy = new EventEmitter();\n  var promise = new PCancelable(function (resolve, reject, onCancel) {\n    var emitter = requestAsEventEmitter(options);\n    onCancel(emitter.abort);\n    emitter.on('response',\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(response) {\n        var stream, data, limitStatusCode, _loop, _i, _Object$entries, _response, statusCode, parseError, error;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                proxy.emit('response', response);\n                stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);\n                _context2.prev = 2;\n                _context2.next = 5;\n                return stream;\n\n              case 5:\n                data = _context2.sent;\n                _context2.next = 12;\n                break;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](2);\n                reject(new ReadError(_context2.t0, options));\n                return _context2.abrupt(\"return\");\n\n              case 12:\n                limitStatusCode = options.followRedirect ? 299 : 399;\n                response.body = data;\n                _context2.prev = 14;\n                _loop =\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _loop() {\n                  var _Object$entries$_i, index, hook;\n\n                  return _regeneratorRuntime.wrap(function _loop$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), index = _Object$entries$_i[0], hook = _Object$entries$_i[1];\n                          _context.next = 3;\n                          return hook(response, function (updatedOptions) {\n                            updatedOptions = reNormalize(mergeOptions(options, _objectSpread({}, updatedOptions, {\n                              retry: 0,\n                              throwHttpErrors: false\n                            }))); // Remove any further hooks for that request, because we we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n\n                            updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n                            return asPromise(updatedOptions);\n                          });\n\n                        case 3:\n                          response = _context.sent;\n\n                        case 4:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n                _i = 0, _Object$entries = Object.entries(options.hooks.afterResponse);\n\n              case 17:\n                if (!(_i < _Object$entries.length)) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                return _context2.delegateYield(_loop(), \"t1\", 19);\n\n              case 19:\n                _i++;\n                _context2.next = 17;\n                break;\n\n              case 22:\n                _context2.next = 28;\n                break;\n\n              case 24:\n                _context2.prev = 24;\n                _context2.t2 = _context2[\"catch\"](14);\n                reject(_context2.t2);\n                return _context2.abrupt(\"return\");\n\n              case 28:\n                _response = response, statusCode = _response.statusCode;\n\n                if (!(options.json && response.body)) {\n                  _context2.next = 41;\n                  break;\n                }\n\n                _context2.prev = 30;\n                response.body = JSON.parse(response.body);\n                _context2.next = 41;\n                break;\n\n              case 34:\n                _context2.prev = 34;\n                _context2.t3 = _context2[\"catch\"](30);\n\n                if (!(statusCode >= 200 && statusCode < 300)) {\n                  _context2.next = 41;\n                  break;\n                }\n\n                parseError = new ParseError(_context2.t3, statusCode, options, data);\n                Object.defineProperty(parseError, 'response', {\n                  value: response\n                });\n                reject(parseError);\n                return _context2.abrupt(\"return\");\n\n              case 41:\n                if (!(statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode))) {\n                  _context2.next = 50;\n                  break;\n                }\n\n                error = new HTTPError(response, options);\n                Object.defineProperty(error, 'response', {\n                  value: response\n                });\n\n                if (!(emitter.retry(error) === false)) {\n                  _context2.next = 49;\n                  break;\n                }\n\n                if (!options.throwHttpErrors) {\n                  _context2.next = 48;\n                  break;\n                }\n\n                reject(error);\n                return _context2.abrupt(\"return\");\n\n              case 48:\n                resolve(response);\n\n              case 49:\n                return _context2.abrupt(\"return\");\n\n              case 50:\n                resolve(response);\n\n              case 51:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee, null, [[2, 8], [14, 24], [30, 34]]);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    emitter.once('error', reject);\n    ['request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(function (event) {\n      return emitter.on(event, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return proxy.emit.apply(proxy, [event].concat(args));\n      });\n    });\n  });\n\n  promise.on = function (name, fn) {\n    proxy.on(name, fn);\n    return promise;\n  };\n\n  return promise;\n};\n\nmodule.exports = asPromise;","map":{"version":3,"sources":["D:/MegaSync/proxy-server/testing/react-express-starter/node_modules/@vitalets/google-translate-api/node_modules/got/source/as-promise.js"],"names":["EventEmitter","require","getStream","is","PCancelable","requestAsEventEmitter","HTTPError","ParseError","ReadError","mergeOptions","options","reNormalize","asPromise","proxy","promise","resolve","reject","onCancel","emitter","abort","on","response","emit","stream","null","encoding","buffer","data","limitStatusCode","followRedirect","body","index","hook","updatedOptions","retry","throwHttpErrors","hooks","afterResponse","slice","Object","entries","statusCode","json","JSON","parse","parseError","defineProperty","value","error","once","forEach","event","args","name","fn","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst getStream = require('get-stream');\nconst is = require('@sindresorhus/is');\nconst PCancelable = require('p-cancelable');\nconst requestAsEventEmitter = require('./request-as-event-emitter');\nconst {HTTPError, ParseError, ReadError} = require('./errors');\nconst {options: mergeOptions} = require('./merge');\nconst {reNormalize} = require('./normalize-arguments');\n\nconst asPromise = options => {\n\tconst proxy = new EventEmitter();\n\n\tconst promise = new PCancelable((resolve, reject, onCancel) => {\n\t\tconst emitter = requestAsEventEmitter(options);\n\n\t\tonCancel(emitter.abort);\n\n\t\temitter.on('response', async response => {\n\t\t\tproxy.emit('response', response);\n\n\t\t\tconst stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);\n\n\t\t\tlet data;\n\t\t\ttry {\n\t\t\t\tdata = await stream;\n\t\t\t} catch (error) {\n\t\t\t\treject(new ReadError(error, options));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst limitStatusCode = options.followRedirect ? 299 : 399;\n\n\t\t\tresponse.body = data;\n\n\t\t\ttry {\n\t\t\t\tfor (const [index, hook] of Object.entries(options.hooks.afterResponse)) {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tresponse = await hook(response, updatedOptions => {\n\t\t\t\t\t\tupdatedOptions = reNormalize(mergeOptions(options, {\n\t\t\t\t\t\t\t...updatedOptions,\n\t\t\t\t\t\t\tretry: 0,\n\t\t\t\t\t\t\tthrowHttpErrors: false\n\t\t\t\t\t\t}));\n\n\t\t\t\t\t\t// Remove any further hooks for that request, because we we'll call them anyway.\n\t\t\t\t\t\t// The loop continues. We don't want duplicates (asPromise recursion).\n\t\t\t\t\t\tupdatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n\n\t\t\t\t\t\treturn asPromise(updatedOptions);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {statusCode} = response;\n\n\t\t\tif (options.json && response.body) {\n\t\t\t\ttry {\n\t\t\t\t\tresponse.body = JSON.parse(response.body);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (statusCode >= 200 && statusCode < 300) {\n\t\t\t\t\t\tconst parseError = new ParseError(error, statusCode, options, data);\n\t\t\t\t\t\tObject.defineProperty(parseError, 'response', {value: response});\n\t\t\t\t\t\treject(parseError);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {\n\t\t\t\tconst error = new HTTPError(response, options);\n\t\t\t\tObject.defineProperty(error, 'response', {value: response});\n\t\t\t\tif (emitter.retry(error) === false) {\n\t\t\t\t\tif (options.throwHttpErrors) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(response);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve(response);\n\t\t});\n\n\t\temitter.once('error', reject);\n\t\t[\n\t\t\t'request',\n\t\t\t'redirect',\n\t\t\t'uploadProgress',\n\t\t\t'downloadProgress'\n\t\t].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n\t});\n\n\tpromise.on = (name, fn) => {\n\t\tproxy.on(name, fn);\n\t\treturn promise;\n\t};\n\n\treturn promise;\n};\n\nmodule.exports = asPromise;\n"]},"metadata":{},"sourceType":"script"}