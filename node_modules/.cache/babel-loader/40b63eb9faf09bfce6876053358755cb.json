{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _require = require('stream'),\n    PassThrough = _require.PassThrough;\n\nvar duplexer3 = require('duplexer3');\n\nvar requestAsEventEmitter = require('./request-as-event-emitter');\n\nvar _require2 = require('./errors'),\n    HTTPError = _require2.HTTPError,\n    ReadError = _require2.ReadError;\n\nmodule.exports = function (options) {\n  var input = new PassThrough();\n  var output = new PassThrough();\n  var proxy = duplexer3(input, output);\n  var piped = new Set();\n  var isFinished = false;\n\n  options.retry.retries = function () {\n    return 0;\n  };\n\n  if (options.body) {\n    proxy.write = function () {\n      throw new Error('Got\\'s stream is not writable when the `body` option is used');\n    };\n  }\n\n  var emitter = requestAsEventEmitter(options, input); // Cancels the request\n\n  proxy._destroy = emitter.abort;\n  emitter.on('response', function (response) {\n    var statusCode = response.statusCode;\n    response.on('error', function (error) {\n      proxy.emit('error', new ReadError(error, options));\n    });\n\n    if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n      proxy.emit('error', new HTTPError(response, options), null, response);\n      return;\n    }\n\n    isFinished = true;\n    response.pipe(output);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = piped[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var destination = _step.value;\n\n        if (destination.headersSent) {\n          continue;\n        }\n\n        for (var _i = 0, _Object$entries = Object.entries(response.headers); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              key = _Object$entries$_i[0],\n              value = _Object$entries$_i[1];\n\n          // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n          // It's not possible to decompress already decompressed data, is it?\n          var allowed = options.decompress ? key !== 'content-encoding' : true;\n\n          if (allowed) {\n            destination.setHeader(key, value);\n          }\n        }\n\n        destination.statusCode = response.statusCode;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    proxy.emit('response', response);\n  });\n  ['error', 'request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(function (event) {\n    return emitter.on(event, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return proxy.emit.apply(proxy, [event].concat(args));\n    });\n  });\n  var pipe = proxy.pipe.bind(proxy);\n  var unpipe = proxy.unpipe.bind(proxy);\n\n  proxy.pipe = function (destination, options) {\n    if (isFinished) {\n      throw new Error('Failed to pipe. The response has been emitted already.');\n    }\n\n    var result = pipe(destination, options);\n\n    if (Reflect.has(destination, 'setHeader')) {\n      piped.add(destination);\n    }\n\n    return result;\n  };\n\n  proxy.unpipe = function (stream) {\n    piped.delete(stream);\n    return unpipe(stream);\n  };\n\n  return proxy;\n};","map":{"version":3,"sources":["D:/MegaSync/proxy-server/testing/react-express-starter/node_modules/@vitalets/google-translate-api/node_modules/got/source/as-stream.js"],"names":["require","PassThrough","duplexer3","requestAsEventEmitter","HTTPError","ReadError","module","exports","options","input","output","proxy","piped","Set","isFinished","retry","retries","body","write","Error","emitter","_destroy","abort","on","response","statusCode","error","emit","throwHttpErrors","pipe","destination","headersSent","Object","entries","headers","key","value","allowed","decompress","setHeader","forEach","event","args","bind","unpipe","result","Reflect","has","add","stream","delete"],"mappings":"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","sourcesContent":["'use strict';\nconst {PassThrough} = require('stream');\nconst duplexer3 = require('duplexer3');\nconst requestAsEventEmitter = require('./request-as-event-emitter');\nconst {HTTPError, ReadError} = require('./errors');\n\nmodule.exports = options => {\n\tconst input = new PassThrough();\n\tconst output = new PassThrough();\n\tconst proxy = duplexer3(input, output);\n\tconst piped = new Set();\n\tlet isFinished = false;\n\n\toptions.retry.retries = () => 0;\n\n\tif (options.body) {\n\t\tproxy.write = () => {\n\t\t\tthrow new Error('Got\\'s stream is not writable when the `body` option is used');\n\t\t};\n\t}\n\n\tconst emitter = requestAsEventEmitter(options, input);\n\n\t// Cancels the request\n\tproxy._destroy = emitter.abort;\n\n\temitter.on('response', response => {\n\t\tconst {statusCode} = response;\n\n\t\tresponse.on('error', error => {\n\t\t\tproxy.emit('error', new ReadError(error, options));\n\t\t});\n\n\t\tif (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n\t\t\tproxy.emit('error', new HTTPError(response, options), null, response);\n\t\t\treturn;\n\t\t}\n\n\t\tisFinished = true;\n\n\t\tresponse.pipe(output);\n\n\t\tfor (const destination of piped) {\n\t\t\tif (destination.headersSent) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const [key, value] of Object.entries(response.headers)) {\n\t\t\t\t// Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n\t\t\t\t// It's not possible to decompress already decompressed data, is it?\n\t\t\t\tconst allowed = options.decompress ? key !== 'content-encoding' : true;\n\t\t\t\tif (allowed) {\n\t\t\t\t\tdestination.setHeader(key, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestination.statusCode = response.statusCode;\n\t\t}\n\n\t\tproxy.emit('response', response);\n\t});\n\n\t[\n\t\t'error',\n\t\t'request',\n\t\t'redirect',\n\t\t'uploadProgress',\n\t\t'downloadProgress'\n\t].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n\n\tconst pipe = proxy.pipe.bind(proxy);\n\tconst unpipe = proxy.unpipe.bind(proxy);\n\tproxy.pipe = (destination, options) => {\n\t\tif (isFinished) {\n\t\t\tthrow new Error('Failed to pipe. The response has been emitted already.');\n\t\t}\n\n\t\tconst result = pipe(destination, options);\n\n\t\tif (Reflect.has(destination, 'setHeader')) {\n\t\t\tpiped.add(destination);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tproxy.unpipe = stream => {\n\t\tpiped.delete(stream);\n\t\treturn unpipe(stream);\n\t};\n\n\treturn proxy;\n};\n"]},"metadata":{},"sourceType":"script"}