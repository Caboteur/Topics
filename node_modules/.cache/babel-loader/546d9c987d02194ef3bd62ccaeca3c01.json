{"ast":null,"code":"'use strict';\n\nvar bufferStream = require('./buffer-stream');\n\nfunction getStream(inputStream, opts) {\n  if (!inputStream) {\n    return Promise.reject(new Error('Expected a stream'));\n  }\n\n  opts = Object.assign({\n    maxBuffer: Infinity\n  }, opts);\n  var maxBuffer = opts.maxBuffer;\n  var stream;\n  var clean;\n  var p = new Promise(function (resolve, reject) {\n    var error = function error(err) {\n      if (err) {\n        // null check\n        err.bufferedData = stream.getBufferedValue();\n      }\n\n      reject(err);\n    };\n\n    stream = bufferStream(opts);\n    inputStream.once('error', error);\n    inputStream.pipe(stream);\n    stream.on('data', function () {\n      if (stream.getBufferedLength() > maxBuffer) {\n        reject(new Error('maxBuffer exceeded'));\n      }\n    });\n    stream.once('error', error);\n    stream.on('end', resolve);\n\n    clean = function clean() {\n      // some streams doesn't implement the `stream.Readable` interface correctly\n      if (inputStream.unpipe) {\n        inputStream.unpipe(stream);\n      }\n    };\n  });\n  p.then(clean, clean);\n  return p.then(function () {\n    return stream.getBufferedValue();\n  });\n}\n\nmodule.exports = getStream;\n\nmodule.exports.buffer = function (stream, opts) {\n  return getStream(stream, Object.assign({}, opts, {\n    encoding: 'buffer'\n  }));\n};\n\nmodule.exports.array = function (stream, opts) {\n  return getStream(stream, Object.assign({}, opts, {\n    array: true\n  }));\n};","map":{"version":3,"sources":["D:/MegaSync/proxy-server/testing/react-express-starter/node_modules/get-stream/index.js"],"names":["bufferStream","require","getStream","inputStream","opts","Promise","reject","Error","Object","assign","maxBuffer","Infinity","stream","clean","p","resolve","error","err","bufferedData","getBufferedValue","once","pipe","on","getBufferedLength","unpipe","then","module","exports","buffer","encoding","array"],"mappings":"AAAA;;AACA,IAAMA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA5B;;AAEA,SAASC,SAAT,CAAmBC,WAAnB,EAAgCC,IAAhC,EAAsC;AACrC,MAAI,CAACD,WAAL,EAAkB;AACjB,WAAOE,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,mBAAV,CAAf,CAAP;AACA;;AAEDH,EAAAA,IAAI,GAAGI,MAAM,CAACC,MAAP,CAAc;AAACC,IAAAA,SAAS,EAAEC;AAAZ,GAAd,EAAqCP,IAArC,CAAP;AAEA,MAAMM,SAAS,GAAGN,IAAI,CAACM,SAAvB;AACA,MAAIE,MAAJ;AACA,MAAIC,KAAJ;AAEA,MAAMC,CAAC,GAAG,IAAIT,OAAJ,CAAY,UAACU,OAAD,EAAUT,MAAV,EAAqB;AAC1C,QAAMU,KAAK,GAAG,SAARA,KAAQ,CAAAC,GAAG,EAAI;AACpB,UAAIA,GAAJ,EAAS;AAAE;AACVA,QAAAA,GAAG,CAACC,YAAJ,GAAmBN,MAAM,CAACO,gBAAP,EAAnB;AACA;;AAEDb,MAAAA,MAAM,CAACW,GAAD,CAAN;AACA,KAND;;AAQAL,IAAAA,MAAM,GAAGZ,YAAY,CAACI,IAAD,CAArB;AACAD,IAAAA,WAAW,CAACiB,IAAZ,CAAiB,OAAjB,EAA0BJ,KAA1B;AACAb,IAAAA,WAAW,CAACkB,IAAZ,CAAiBT,MAAjB;AAEAA,IAAAA,MAAM,CAACU,EAAP,CAAU,MAAV,EAAkB,YAAM;AACvB,UAAIV,MAAM,CAACW,iBAAP,KAA6Bb,SAAjC,EAA4C;AAC3CJ,QAAAA,MAAM,CAAC,IAAIC,KAAJ,CAAU,oBAAV,CAAD,CAAN;AACA;AACD,KAJD;AAKAK,IAAAA,MAAM,CAACQ,IAAP,CAAY,OAAZ,EAAqBJ,KAArB;AACAJ,IAAAA,MAAM,CAACU,EAAP,CAAU,KAAV,EAAiBP,OAAjB;;AAEAF,IAAAA,KAAK,GAAG,iBAAM;AACb;AACA,UAAIV,WAAW,CAACqB,MAAhB,EAAwB;AACvBrB,QAAAA,WAAW,CAACqB,MAAZ,CAAmBZ,MAAnB;AACA;AACD,KALD;AAMA,GA3BS,CAAV;AA6BAE,EAAAA,CAAC,CAACW,IAAF,CAAOZ,KAAP,EAAcA,KAAd;AAEA,SAAOC,CAAC,CAACW,IAAF,CAAO;AAAA,WAAMb,MAAM,CAACO,gBAAP,EAAN;AAAA,GAAP,CAAP;AACA;;AAEDO,MAAM,CAACC,OAAP,GAAiBzB,SAAjB;;AACAwB,MAAM,CAACC,OAAP,CAAeC,MAAf,GAAwB,UAAChB,MAAD,EAASR,IAAT;AAAA,SAAkBF,SAAS,CAACU,MAAD,EAASJ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,IAAlB,EAAwB;AAACyB,IAAAA,QAAQ,EAAE;AAAX,GAAxB,CAAT,CAA3B;AAAA,CAAxB;;AACAH,MAAM,CAACC,OAAP,CAAeG,KAAf,GAAuB,UAAClB,MAAD,EAASR,IAAT;AAAA,SAAkBF,SAAS,CAACU,MAAD,EAASJ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,IAAlB,EAAwB;AAAC0B,IAAAA,KAAK,EAAE;AAAR,GAAxB,CAAT,CAA3B;AAAA,CAAvB","sourcesContent":["'use strict';\nconst bufferStream = require('./buffer-stream');\n\nfunction getStream(inputStream, opts) {\n\tif (!inputStream) {\n\t\treturn Promise.reject(new Error('Expected a stream'));\n\t}\n\n\topts = Object.assign({maxBuffer: Infinity}, opts);\n\n\tconst maxBuffer = opts.maxBuffer;\n\tlet stream;\n\tlet clean;\n\n\tconst p = new Promise((resolve, reject) => {\n\t\tconst error = err => {\n\t\t\tif (err) { // null check\n\t\t\t\terr.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(err);\n\t\t};\n\n\t\tstream = bufferStream(opts);\n\t\tinputStream.once('error', error);\n\t\tinputStream.pipe(stream);\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\treject(new Error('maxBuffer exceeded'));\n\t\t\t}\n\t\t});\n\t\tstream.once('error', error);\n\t\tstream.on('end', resolve);\n\n\t\tclean = () => {\n\t\t\t// some streams doesn't implement the `stream.Readable` interface correctly\n\t\t\tif (inputStream.unpipe) {\n\t\t\t\tinputStream.unpipe(stream);\n\t\t\t}\n\t\t};\n\t});\n\n\tp.then(clean, clean);\n\n\treturn p.then(() => stream.getBufferedValue());\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, {encoding: 'buffer'}));\nmodule.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, {array: true}));\n"]},"metadata":{},"sourceType":"script"}