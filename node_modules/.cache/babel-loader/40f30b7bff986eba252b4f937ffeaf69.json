{"ast":null,"code":"'use strict'; // rfc7231 6.1\n\nvar _classCallCheck = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"D:\\\\MegaSync\\\\proxy-server\\\\testing\\\\react-express-starter\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar statusCodeCacheableByDefault = new Set([200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501]); // This implementation does not understand partial responses (206)\n\nvar understoodStatuses = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]);\nvar errorStatusCodes = new Set([500, 502, 503, 504]);\nvar hopByHopHeaders = {\n  date: true,\n  // included, because we add Age update Date\n  connection: true,\n  'keep-alive': true,\n  'proxy-authenticate': true,\n  'proxy-authorization': true,\n  te: true,\n  trailer: true,\n  'transfer-encoding': true,\n  upgrade: true\n};\nvar excludedFromRevalidationUpdate = {\n  // Since the old body is reused, it doesn't make sense to change properties of the body\n  'content-length': true,\n  'content-encoding': true,\n  'transfer-encoding': true,\n  'content-range': true\n};\n\nfunction toNumberOrZero(s) {\n  var n = parseInt(s, 10);\n  return isFinite(n) ? n : 0;\n} // RFC 5861\n\n\nfunction isErrorResponse(response) {\n  // consider undefined response as faulty\n  if (!response) {\n    return true;\n  }\n\n  return errorStatusCodes.has(response.status);\n}\n\nfunction parseCacheControl(header) {\n  var cc = {};\n  if (!header) return cc; // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n  // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n\n  var parts = header.trim().split(/\\s*,\\s*/); // TODO: lame parsing\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var part = _step.value;\n\n      var _part$split = part.split(/\\s*=\\s*/, 2),\n          _part$split2 = _slicedToArray(_part$split, 2),\n          k = _part$split2[0],\n          v = _part$split2[1];\n\n      cc[k] = v === undefined ? true : v.replace(/^\"|\"$/g, ''); // TODO: lame unquoting\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return cc;\n}\n\nfunction formatCacheControl(cc) {\n  var parts = [];\n\n  for (var k in cc) {\n    var v = cc[k];\n    parts.push(v === true ? k : k + '=' + v);\n  }\n\n  if (!parts.length) {\n    return undefined;\n  }\n\n  return parts.join(', ');\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function CachePolicy(req, res) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        shared = _ref.shared,\n        cacheHeuristic = _ref.cacheHeuristic,\n        immutableMinTimeToLive = _ref.immutableMinTimeToLive,\n        ignoreCargoCult = _ref.ignoreCargoCult,\n        _fromObject = _ref._fromObject;\n\n    _classCallCheck(this, CachePolicy);\n\n    if (_fromObject) {\n      this._fromObject(_fromObject);\n\n      return;\n    }\n\n    if (!res || !res.headers) {\n      throw Error('Response headers missing');\n    }\n\n    this._assertRequestHasHeaders(req);\n\n    this._responseTime = this.now();\n    this._isShared = shared !== false;\n    this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n\n    this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;\n    this._status = 'status' in res ? res.status : 200;\n    this._resHeaders = res.headers;\n    this._rescc = parseCacheControl(res.headers['cache-control']);\n    this._method = 'method' in req ? req.method : 'GET';\n    this._url = req.url;\n    this._host = req.headers.host;\n    this._noAuthorization = !req.headers.authorization;\n    this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n\n    this._reqcc = parseCacheControl(req.headers['cache-control']); // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n    // so there's no point stricly adhering to the blindly copy&pasted directives.\n\n    if (ignoreCargoCult && 'pre-check' in this._rescc && 'post-check' in this._rescc) {\n      delete this._rescc['pre-check'];\n      delete this._rescc['post-check'];\n      delete this._rescc['no-cache'];\n      delete this._rescc['no-store'];\n      delete this._rescc['must-revalidate'];\n      this._resHeaders = Object.assign({}, this._resHeaders, {\n        'cache-control': formatCacheControl(this._rescc)\n      });\n      delete this._resHeaders.expires;\n      delete this._resHeaders.pragma;\n    } // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n    // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n\n\n    if (res.headers['cache-control'] == null && /no-cache/.test(res.headers.pragma)) {\n      this._rescc['no-cache'] = true;\n    }\n  }\n\n  _createClass(CachePolicy, [{\n    key: \"now\",\n    value: function now() {\n      return Date.now();\n    }\n  }, {\n    key: \"storable\",\n    value: function storable() {\n      // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n      return !!(!this._reqcc['no-store'] && ( // A cache MUST NOT store a response to any request, unless:\n      // The request method is understood by the cache and defined as being cacheable, and\n      'GET' === this._method || 'HEAD' === this._method || 'POST' === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and\n      understoodStatuses.has(this._status) && // the \"no-store\" cache directive does not appear in request or response header fields, and\n      !this._rescc['no-store'] && ( // the \"private\" response directive does not appear in the response, if the cache is shared, and\n      !this._isShared || !this._rescc.private) && ( // the Authorization header field does not appear in the request, if the cache is shared,\n      !this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && ( // the response either:\n      // contains an Expires header field, or\n      this._resHeaders.expires || // contains a max-age response directive, or\n      // contains a s-maxage response directive and the cache is shared, or\n      // contains a public response directive.\n      this._rescc['max-age'] || this._isShared && this._rescc['s-maxage'] || this._rescc.public || // has a status code that is defined as cacheable by default\n      statusCodeCacheableByDefault.has(this._status)));\n    }\n  }, {\n    key: \"_hasExplicitExpiration\",\n    value: function _hasExplicitExpiration() {\n      // 4.2.1 Calculating Freshness Lifetime\n      return this._isShared && this._rescc['s-maxage'] || this._rescc['max-age'] || this._resHeaders.expires;\n    }\n  }, {\n    key: \"_assertRequestHasHeaders\",\n    value: function _assertRequestHasHeaders(req) {\n      if (!req || !req.headers) {\n        throw Error('Request headers missing');\n      }\n    }\n  }, {\n    key: \"satisfiesWithoutRevalidation\",\n    value: function satisfiesWithoutRevalidation(req) {\n      this._assertRequestHasHeaders(req); // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n      // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n      // unless the stored response is successfully validated (Section 4.3), and\n\n\n      var requestCC = parseCacheControl(req.headers['cache-control']);\n\n      if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n        return false;\n      }\n\n      if (requestCC['max-age'] && this.age() > requestCC['max-age']) {\n        return false;\n      }\n\n      if (requestCC['min-fresh'] && this.timeToLive() < 1000 * requestCC['min-fresh']) {\n        return false;\n      } // the stored response is either:\n      // fresh, or allowed to be served stale\n\n\n      if (this.stale()) {\n        var allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n\n        if (!allowsStale) {\n          return false;\n        }\n      }\n\n      return this._requestMatches(req, false);\n    }\n  }, {\n    key: \"_requestMatches\",\n    value: function _requestMatches(req, allowHeadMethod) {\n      // The presented effective request URI and that of the stored response match, and\n      return (!this._url || this._url === req.url) && this._host === req.headers.host && ( // the request method associated with the stored response allows it to be used for the presented request, and\n      !req.method || this._method === req.method || allowHeadMethod && 'HEAD' === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and\n      this._varyMatches(req);\n    }\n  }, {\n    key: \"_allowsStoringAuthenticated\",\n    value: function _allowsStoringAuthenticated() {\n      //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n      return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];\n    }\n  }, {\n    key: \"_varyMatches\",\n    value: function _varyMatches(req) {\n      if (!this._resHeaders.vary) {\n        return true;\n      } // A Vary header field-value of \"*\" always fails to match\n\n\n      if (this._resHeaders.vary === '*') {\n        return false;\n      }\n\n      var fields = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = fields[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var name = _step2.value;\n          if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_copyWithoutHopByHopHeaders\",\n    value: function _copyWithoutHopByHopHeaders(inHeaders) {\n      var headers = {};\n\n      for (var name in inHeaders) {\n        if (hopByHopHeaders[name]) continue;\n        headers[name] = inHeaders[name];\n      } // 9.1.  Connection\n\n\n      if (inHeaders.connection) {\n        var tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = tokens[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _name = _step3.value;\n            delete headers[_name];\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      if (headers.warning) {\n        var warnings = headers.warning.split(/,/).filter(function (warning) {\n          return !/^\\s*1[0-9][0-9]/.test(warning);\n        });\n\n        if (!warnings.length) {\n          delete headers.warning;\n        } else {\n          headers.warning = warnings.join(',').trim();\n        }\n      }\n\n      return headers;\n    }\n  }, {\n    key: \"responseHeaders\",\n    value: function responseHeaders() {\n      var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n\n      var age = this.age(); // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n      // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n\n      if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {\n        headers.warning = (headers.warning ? \"\".concat(headers.warning, \", \") : '') + '113 - \"rfc7234 5.5.4\"';\n      }\n\n      headers.age = \"\".concat(Math.round(age));\n      headers.date = new Date(this.now()).toUTCString();\n      return headers;\n    }\n    /**\n     * Value of the Date response header or current time if Date was invalid\n     * @return timestamp\n     */\n\n  }, {\n    key: \"date\",\n    value: function date() {\n      var serverDate = Date.parse(this._resHeaders.date);\n\n      if (isFinite(serverDate)) {\n        return serverDate;\n      }\n\n      return this._responseTime;\n    }\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     *\n     * @return Number\n     */\n\n  }, {\n    key: \"age\",\n    value: function age() {\n      var age = this._ageValue();\n\n      var residentTime = (this.now() - this._responseTime) / 1000;\n      return age + residentTime;\n    }\n  }, {\n    key: \"_ageValue\",\n    value: function _ageValue() {\n      return toNumberOrZero(this._resHeaders.age);\n    }\n    /**\n     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * @return Number\n     */\n\n  }, {\n    key: \"maxAge\",\n    value: function maxAge() {\n      if (!this.storable() || this._rescc['no-cache']) {\n        return 0;\n      } // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n      // so this implementation requires explicit opt-in via public header\n\n\n      if (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) {\n        return 0;\n      }\n\n      if (this._resHeaders.vary === '*') {\n        return 0;\n      }\n\n      if (this._isShared) {\n        if (this._rescc['proxy-revalidate']) {\n          return 0;\n        } // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n\n\n        if (this._rescc['s-maxage']) {\n          return toNumberOrZero(this._rescc['s-maxage']);\n        }\n      } // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n\n\n      if (this._rescc['max-age']) {\n        return toNumberOrZero(this._rescc['max-age']);\n      }\n\n      var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n      var serverDate = this.date();\n\n      if (this._resHeaders.expires) {\n        var expires = Date.parse(this._resHeaders.expires); // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n\n        if (Number.isNaN(expires) || expires < serverDate) {\n          return 0;\n        }\n\n        return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n      }\n\n      if (this._resHeaders['last-modified']) {\n        var lastModified = Date.parse(this._resHeaders['last-modified']);\n\n        if (isFinite(lastModified) && serverDate > lastModified) {\n          return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);\n        }\n      }\n\n      return defaultMinTtl;\n    }\n  }, {\n    key: \"timeToLive\",\n    value: function timeToLive() {\n      var age = this.maxAge() - this.age();\n      var staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n      var staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n      return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;\n    }\n  }, {\n    key: \"stale\",\n    value: function stale() {\n      return this.maxAge() <= this.age();\n    }\n  }, {\n    key: \"_useStaleIfError\",\n    value: function _useStaleIfError() {\n      return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n    }\n  }, {\n    key: \"useStaleWhileRevalidate\",\n    value: function useStaleWhileRevalidate() {\n      return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();\n    }\n  }, {\n    key: \"_fromObject\",\n    value: function _fromObject(obj) {\n      if (this._responseTime) throw Error('Reinitialized');\n      if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n      this._responseTime = obj.t;\n      this._isShared = obj.sh;\n      this._cacheHeuristic = obj.ch;\n      this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n      this._status = obj.st;\n      this._resHeaders = obj.resh;\n      this._rescc = obj.rescc;\n      this._method = obj.m;\n      this._url = obj.u;\n      this._host = obj.h;\n      this._noAuthorization = obj.a;\n      this._reqHeaders = obj.reqh;\n      this._reqcc = obj.reqcc;\n    }\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        v: 1,\n        t: this._responseTime,\n        sh: this._isShared,\n        ch: this._cacheHeuristic,\n        imm: this._immutableMinTtl,\n        st: this._status,\n        resh: this._resHeaders,\n        rescc: this._rescc,\n        m: this._method,\n        u: this._url,\n        h: this._host,\n        a: this._noAuthorization,\n        reqh: this._reqHeaders,\n        reqcc: this._reqcc\n      };\n    }\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     */\n\n  }, {\n    key: \"revalidationHeaders\",\n    value: function revalidationHeaders(incomingReq) {\n      this._assertRequestHasHeaders(incomingReq);\n\n      var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers); // This implementation does not understand range requests\n\n\n      delete headers['if-range'];\n\n      if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n        // revalidation allowed via HEAD\n        // not for the same resource, or wasn't allowed to be cached anyway\n        delete headers['if-none-match'];\n        delete headers['if-modified-since'];\n        return headers;\n      }\n      /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n\n\n      if (this._resHeaders.etag) {\n        headers['if-none-match'] = headers['if-none-match'] ? \"\".concat(headers['if-none-match'], \", \").concat(this._resHeaders.etag) : this._resHeaders.etag;\n      } // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n\n\n      var forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || this._method && this._method != 'GET';\n      /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n      Note: This implementation does not understand partial responses (206) */\n\n      if (forbidsWeakValidators) {\n        delete headers['if-modified-since'];\n\n        if (headers['if-none-match']) {\n          var etags = headers['if-none-match'].split(/,/).filter(function (etag) {\n            return !/^\\s*W\\//.test(etag);\n          });\n\n          if (!etags.length) {\n            delete headers['if-none-match'];\n          } else {\n            headers['if-none-match'] = etags.join(',').trim();\n          }\n        }\n      } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {\n        headers['if-modified-since'] = this._resHeaders['last-modified'];\n      }\n\n      return headers;\n    }\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @return {Object} {policy: CachePolicy, modified: Boolean}\n     */\n\n  }, {\n    key: \"revalidatedPolicy\",\n    value: function revalidatedPolicy(request, response) {\n      this._assertRequestHasHeaders(request);\n\n      if (this._useStaleIfError() && isErrorResponse(response)) {\n        // I consider the revalidation request unsuccessful\n        return {\n          modified: false,\n          matches: false,\n          policy: this\n        };\n      }\n\n      if (!response || !response.headers) {\n        throw Error('Response headers missing');\n      } // These aren't going to be supported exactly, since one CachePolicy object\n      // doesn't know about all the other cached objects.\n\n\n      var matches = false;\n\n      if (response.status !== undefined && response.status != 304) {\n        matches = false;\n      } else if (response.headers.etag && !/^\\s*W\\//.test(response.headers.etag)) {\n        // \"All of the stored responses with the same strong validator are selected.\n        // If none of the stored responses contain the same strong validator,\n        // then the cache MUST NOT use the new response to update any stored responses.\"\n        matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag;\n      } else if (this._resHeaders.etag && response.headers.etag) {\n        // \"If the new response contains a weak validator and that validator corresponds\n        // to one of the cache's stored responses,\n        // then the most recent of those matching stored responses is selected for update.\"\n        matches = this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag.replace(/^\\s*W\\//, '');\n      } else if (this._resHeaders['last-modified']) {\n        matches = this._resHeaders['last-modified'] === response.headers['last-modified'];\n      } else {\n        // If the new response does not include any form of validator (such as in the case where\n        // a client generates an If-Modified-Since request from a source other than the Last-Modified\n        // response header field), and there is only one stored response, and that stored response also\n        // lacks a validator, then that stored response is selected for update.\n        if (!this._resHeaders.etag && !this._resHeaders['last-modified'] && !response.headers.etag && !response.headers['last-modified']) {\n          matches = true;\n        }\n      }\n\n      if (!matches) {\n        return {\n          policy: new this.constructor(request, response),\n          // Client receiving 304 without body, even if it's invalid/mismatched has no option\n          // but to reuse a cached body. We don't have a good way to tell clients to do\n          // error recovery in such case.\n          modified: response.status != 304,\n          matches: false\n        };\n      } // use other header fields provided in the 304 (Not Modified) response to replace all instances\n      // of the corresponding header fields in the stored response.\n\n\n      var headers = {};\n\n      for (var k in this._resHeaders) {\n        headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];\n      }\n\n      var newResponse = Object.assign({}, response, {\n        status: this._status,\n        method: this._method,\n        headers: headers\n      });\n      return {\n        policy: new this.constructor(request, newResponse, {\n          shared: this._isShared,\n          cacheHeuristic: this._cacheHeuristic,\n          immutableMinTimeToLive: this._immutableMinTtl\n        }),\n        modified: false,\n        matches: true\n      };\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(obj) {\n      return new this(undefined, undefined, {\n        _fromObject: obj\n      });\n    }\n  }]);\n\n  return CachePolicy;\n}();","map":{"version":3,"sources":["D:/MegaSync/proxy-server/testing/react-express-starter/node_modules/http-cache-semantics/index.js"],"names":["statusCodeCacheableByDefault","Set","understoodStatuses","errorStatusCodes","hopByHopHeaders","date","connection","te","trailer","upgrade","excludedFromRevalidationUpdate","toNumberOrZero","s","n","parseInt","isFinite","isErrorResponse","response","has","status","parseCacheControl","header","cc","parts","trim","split","part","k","v","undefined","replace","formatCacheControl","push","length","join","module","exports","req","res","shared","cacheHeuristic","immutableMinTimeToLive","ignoreCargoCult","_fromObject","headers","Error","_assertRequestHasHeaders","_responseTime","now","_isShared","_cacheHeuristic","_immutableMinTtl","_status","_resHeaders","_rescc","_method","method","_url","url","_host","host","_noAuthorization","authorization","_reqHeaders","vary","_reqcc","Object","assign","expires","pragma","test","Date","_hasExplicitExpiration","private","_allowsStoringAuthenticated","public","requestCC","age","timeToLive","stale","allowsStale","maxAge","_requestMatches","allowHeadMethod","_varyMatches","fields","toLowerCase","name","inHeaders","tokens","warning","warnings","filter","_copyWithoutHopByHopHeaders","Math","round","toUTCString","serverDate","parse","_ageValue","residentTime","storable","immutable","defaultMinTtl","Number","isNaN","max","lastModified","staleIfErrorAge","staleWhileRevalidateAge","obj","t","sh","ch","imm","st","resh","rescc","m","u","h","a","reqh","reqcc","incomingReq","etag","forbidsWeakValidators","etags","request","_useStaleIfError","modified","matches","policy","constructor","newResponse"],"mappings":"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","sourcesContent":["'use strict';\n// rfc7231 6.1\nconst statusCodeCacheableByDefault = new Set([\n    200,\n    203,\n    204,\n    206,\n    300,\n    301,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\n// This implementation does not understand partial responses (206)\nconst understoodStatuses = new Set([\n    200,\n    203,\n    204,\n    300,\n    301,\n    302,\n    303,\n    307,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\nconst errorStatusCodes = new Set([\n    500,\n    502,\n    503, \n    504,\n]);\n\nconst hopByHopHeaders = {\n    date: true, // included, because we add Age update Date\n    connection: true,\n    'keep-alive': true,\n    'proxy-authenticate': true,\n    'proxy-authorization': true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n};\n\nconst excludedFromRevalidationUpdate = {\n    // Since the old body is reused, it doesn't make sense to change properties of the body\n    'content-length': true,\n    'content-encoding': true,\n    'transfer-encoding': true,\n    'content-range': true,\n};\n\nfunction toNumberOrZero(s) {\n    const n = parseInt(s, 10);\n    return isFinite(n) ? n : 0;\n}\n\n// RFC 5861\nfunction isErrorResponse(response) {\n    // consider undefined response as faulty\n    if(!response) {\n        return true\n    }\n    return errorStatusCodes.has(response.status);\n}\n\nfunction parseCacheControl(header) {\n    const cc = {};\n    if (!header) return cc;\n\n    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n    const parts = header.trim().split(/\\s*,\\s*/); // TODO: lame parsing\n    for (const part of parts) {\n        const [k, v] = part.split(/\\s*=\\s*/, 2);\n        cc[k] = v === undefined ? true : v.replace(/^\"|\"$/g, ''); // TODO: lame unquoting\n    }\n\n    return cc;\n}\n\nfunction formatCacheControl(cc) {\n    let parts = [];\n    for (const k in cc) {\n        const v = cc[k];\n        parts.push(v === true ? k : k + '=' + v);\n    }\n    if (!parts.length) {\n        return undefined;\n    }\n    return parts.join(', ');\n}\n\nmodule.exports = class CachePolicy {\n    constructor(\n        req,\n        res,\n        {\n            shared,\n            cacheHeuristic,\n            immutableMinTimeToLive,\n            ignoreCargoCult,\n            _fromObject,\n        } = {}\n    ) {\n        if (_fromObject) {\n            this._fromObject(_fromObject);\n            return;\n        }\n\n        if (!res || !res.headers) {\n            throw Error('Response headers missing');\n        }\n        this._assertRequestHasHeaders(req);\n\n        this._responseTime = this.now();\n        this._isShared = shared !== false;\n        this._cacheHeuristic =\n            undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n        this._immutableMinTtl =\n            undefined !== immutableMinTimeToLive\n                ? immutableMinTimeToLive\n                : 24 * 3600 * 1000;\n\n        this._status = 'status' in res ? res.status : 200;\n        this._resHeaders = res.headers;\n        this._rescc = parseCacheControl(res.headers['cache-control']);\n        this._method = 'method' in req ? req.method : 'GET';\n        this._url = req.url;\n        this._host = req.headers.host;\n        this._noAuthorization = !req.headers.authorization;\n        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n        this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n        // so there's no point stricly adhering to the blindly copy&pasted directives.\n        if (\n            ignoreCargoCult &&\n            'pre-check' in this._rescc &&\n            'post-check' in this._rescc\n        ) {\n            delete this._rescc['pre-check'];\n            delete this._rescc['post-check'];\n            delete this._rescc['no-cache'];\n            delete this._rescc['no-store'];\n            delete this._rescc['must-revalidate'];\n            this._resHeaders = Object.assign({}, this._resHeaders, {\n                'cache-control': formatCacheControl(this._rescc),\n            });\n            delete this._resHeaders.expires;\n            delete this._resHeaders.pragma;\n        }\n\n        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n        // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n        if (\n            res.headers['cache-control'] == null &&\n            /no-cache/.test(res.headers.pragma)\n        ) {\n            this._rescc['no-cache'] = true;\n        }\n    }\n\n    now() {\n        return Date.now();\n    }\n\n    storable() {\n        // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n        return !!(\n            !this._reqcc['no-store'] &&\n            // A cache MUST NOT store a response to any request, unless:\n            // The request method is understood by the cache and defined as being cacheable, and\n            ('GET' === this._method ||\n                'HEAD' === this._method ||\n                ('POST' === this._method && this._hasExplicitExpiration())) &&\n            // the response status code is understood by the cache, and\n            understoodStatuses.has(this._status) &&\n            // the \"no-store\" cache directive does not appear in request or response header fields, and\n            !this._rescc['no-store'] &&\n            // the \"private\" response directive does not appear in the response, if the cache is shared, and\n            (!this._isShared || !this._rescc.private) &&\n            // the Authorization header field does not appear in the request, if the cache is shared,\n            (!this._isShared ||\n                this._noAuthorization ||\n                this._allowsStoringAuthenticated()) &&\n            // the response either:\n            // contains an Expires header field, or\n            (this._resHeaders.expires ||\n                // contains a max-age response directive, or\n                // contains a s-maxage response directive and the cache is shared, or\n                // contains a public response directive.\n                this._rescc['max-age'] ||\n                (this._isShared && this._rescc['s-maxage']) ||\n                this._rescc.public ||\n                // has a status code that is defined as cacheable by default\n                statusCodeCacheableByDefault.has(this._status))\n        );\n    }\n\n    _hasExplicitExpiration() {\n        // 4.2.1 Calculating Freshness Lifetime\n        return (\n            (this._isShared && this._rescc['s-maxage']) ||\n            this._rescc['max-age'] ||\n            this._resHeaders.expires\n        );\n    }\n\n    _assertRequestHasHeaders(req) {\n        if (!req || !req.headers) {\n            throw Error('Request headers missing');\n        }\n    }\n\n    satisfiesWithoutRevalidation(req) {\n        this._assertRequestHasHeaders(req);\n\n        // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n        // unless the stored response is successfully validated (Section 4.3), and\n        const requestCC = parseCacheControl(req.headers['cache-control']);\n        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n            return false;\n        }\n\n        if (requestCC['max-age'] && this.age() > requestCC['max-age']) {\n            return false;\n        }\n\n        if (\n            requestCC['min-fresh'] &&\n            this.timeToLive() < 1000 * requestCC['min-fresh']\n        ) {\n            return false;\n        }\n\n        // the stored response is either:\n        // fresh, or allowed to be served stale\n        if (this.stale()) {\n            const allowsStale =\n                requestCC['max-stale'] &&\n                !this._rescc['must-revalidate'] &&\n                (true === requestCC['max-stale'] ||\n                    requestCC['max-stale'] > this.age() - this.maxAge());\n            if (!allowsStale) {\n                return false;\n            }\n        }\n\n        return this._requestMatches(req, false);\n    }\n\n    _requestMatches(req, allowHeadMethod) {\n        // The presented effective request URI and that of the stored response match, and\n        return (\n            (!this._url || this._url === req.url) &&\n            this._host === req.headers.host &&\n            // the request method associated with the stored response allows it to be used for the presented request, and\n            (!req.method ||\n                this._method === req.method ||\n                (allowHeadMethod && 'HEAD' === req.method)) &&\n            // selecting header fields nominated by the stored response (if any) match those presented, and\n            this._varyMatches(req)\n        );\n    }\n\n    _allowsStoringAuthenticated() {\n        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n        return (\n            this._rescc['must-revalidate'] ||\n            this._rescc.public ||\n            this._rescc['s-maxage']\n        );\n    }\n\n    _varyMatches(req) {\n        if (!this._resHeaders.vary) {\n            return true;\n        }\n\n        // A Vary header field-value of \"*\" always fails to match\n        if (this._resHeaders.vary === '*') {\n            return false;\n        }\n\n        const fields = this._resHeaders.vary\n            .trim()\n            .toLowerCase()\n            .split(/\\s*,\\s*/);\n        for (const name of fields) {\n            if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n        return true;\n    }\n\n    _copyWithoutHopByHopHeaders(inHeaders) {\n        const headers = {};\n        for (const name in inHeaders) {\n            if (hopByHopHeaders[name]) continue;\n            headers[name] = inHeaders[name];\n        }\n        // 9.1.  Connection\n        if (inHeaders.connection) {\n            const tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n            for (const name of tokens) {\n                delete headers[name];\n            }\n        }\n        if (headers.warning) {\n            const warnings = headers.warning.split(/,/).filter(warning => {\n                return !/^\\s*1[0-9][0-9]/.test(warning);\n            });\n            if (!warnings.length) {\n                delete headers.warning;\n            } else {\n                headers.warning = warnings.join(',').trim();\n            }\n        }\n        return headers;\n    }\n\n    responseHeaders() {\n        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n        const age = this.age();\n\n        // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n        // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n        if (\n            age > 3600 * 24 &&\n            !this._hasExplicitExpiration() &&\n            this.maxAge() > 3600 * 24\n        ) {\n            headers.warning =\n                (headers.warning ? `${headers.warning}, ` : '') +\n                '113 - \"rfc7234 5.5.4\"';\n        }\n        headers.age = `${Math.round(age)}`;\n        headers.date = new Date(this.now()).toUTCString();\n        return headers;\n    }\n\n    /**\n     * Value of the Date response header or current time if Date was invalid\n     * @return timestamp\n     */\n    date() {\n        const serverDate = Date.parse(this._resHeaders.date);\n        if (isFinite(serverDate)) {\n            return serverDate;\n        }\n        return this._responseTime;\n    }\n\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     *\n     * @return Number\n     */\n    age() {\n        let age = this._ageValue();\n\n        const residentTime = (this.now() - this._responseTime) / 1000;\n        return age + residentTime;\n    }\n\n    _ageValue() {\n        return toNumberOrZero(this._resHeaders.age);\n    }\n\n    /**\n     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * @return Number\n     */\n    maxAge() {\n        if (!this.storable() || this._rescc['no-cache']) {\n            return 0;\n        }\n\n        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n        // so this implementation requires explicit opt-in via public header\n        if (\n            this._isShared &&\n            (this._resHeaders['set-cookie'] &&\n                !this._rescc.public &&\n                !this._rescc.immutable)\n        ) {\n            return 0;\n        }\n\n        if (this._resHeaders.vary === '*') {\n            return 0;\n        }\n\n        if (this._isShared) {\n            if (this._rescc['proxy-revalidate']) {\n                return 0;\n            }\n            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n            if (this._rescc['s-maxage']) {\n                return toNumberOrZero(this._rescc['s-maxage']);\n            }\n        }\n\n        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n        if (this._rescc['max-age']) {\n            return toNumberOrZero(this._rescc['max-age']);\n        }\n\n        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n\n        const serverDate = this.date();\n        if (this._resHeaders.expires) {\n            const expires = Date.parse(this._resHeaders.expires);\n            // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n            if (Number.isNaN(expires) || expires < serverDate) {\n                return 0;\n            }\n            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n        }\n\n        if (this._resHeaders['last-modified']) {\n            const lastModified = Date.parse(this._resHeaders['last-modified']);\n            if (isFinite(lastModified) && serverDate > lastModified) {\n                return Math.max(\n                    defaultMinTtl,\n                    ((serverDate - lastModified) / 1000) * this._cacheHeuristic\n                );\n            }\n        }\n\n        return defaultMinTtl;\n    }\n\n    timeToLive() {\n        const age = this.maxAge() - this.age();\n        const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;\n    }\n\n    stale() {\n        return this.maxAge() <= this.age();\n    }\n\n    _useStaleIfError() {\n        return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n    }\n\n    useStaleWhileRevalidate() {\n        return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();\n    }\n\n    static fromObject(obj) {\n        return new this(undefined, undefined, { _fromObject: obj });\n    }\n\n    _fromObject(obj) {\n        if (this._responseTime) throw Error('Reinitialized');\n        if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n\n        this._responseTime = obj.t;\n        this._isShared = obj.sh;\n        this._cacheHeuristic = obj.ch;\n        this._immutableMinTtl =\n            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n        this._status = obj.st;\n        this._resHeaders = obj.resh;\n        this._rescc = obj.rescc;\n        this._method = obj.m;\n        this._url = obj.u;\n        this._host = obj.h;\n        this._noAuthorization = obj.a;\n        this._reqHeaders = obj.reqh;\n        this._reqcc = obj.reqcc;\n    }\n\n    toObject() {\n        return {\n            v: 1,\n            t: this._responseTime,\n            sh: this._isShared,\n            ch: this._cacheHeuristic,\n            imm: this._immutableMinTtl,\n            st: this._status,\n            resh: this._resHeaders,\n            rescc: this._rescc,\n            m: this._method,\n            u: this._url,\n            h: this._host,\n            a: this._noAuthorization,\n            reqh: this._reqHeaders,\n            reqcc: this._reqcc,\n        };\n    }\n\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     */\n    revalidationHeaders(incomingReq) {\n        this._assertRequestHasHeaders(incomingReq);\n        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n        // This implementation does not understand range requests\n        delete headers['if-range'];\n\n        if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n            // revalidation allowed via HEAD\n            // not for the same resource, or wasn't allowed to be cached anyway\n            delete headers['if-none-match'];\n            delete headers['if-modified-since'];\n            return headers;\n        }\n\n        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n        if (this._resHeaders.etag) {\n            headers['if-none-match'] = headers['if-none-match']\n                ? `${headers['if-none-match']}, ${this._resHeaders.etag}`\n                : this._resHeaders.etag;\n        }\n\n        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n        const forbidsWeakValidators =\n            headers['accept-ranges'] ||\n            headers['if-match'] ||\n            headers['if-unmodified-since'] ||\n            (this._method && this._method != 'GET');\n\n        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n        Note: This implementation does not understand partial responses (206) */\n        if (forbidsWeakValidators) {\n            delete headers['if-modified-since'];\n\n            if (headers['if-none-match']) {\n                const etags = headers['if-none-match']\n                    .split(/,/)\n                    .filter(etag => {\n                        return !/^\\s*W\\//.test(etag);\n                    });\n                if (!etags.length) {\n                    delete headers['if-none-match'];\n                } else {\n                    headers['if-none-match'] = etags.join(',').trim();\n                }\n            }\n        } else if (\n            this._resHeaders['last-modified'] &&\n            !headers['if-modified-since']\n        ) {\n            headers['if-modified-since'] = this._resHeaders['last-modified'];\n        }\n\n        return headers;\n    }\n\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @return {Object} {policy: CachePolicy, modified: Boolean}\n     */\n    revalidatedPolicy(request, response) {\n        this._assertRequestHasHeaders(request);\n        if(this._useStaleIfError() && isErrorResponse(response)) {  // I consider the revalidation request unsuccessful\n          return {\n            modified: false,\n            matches: false,\n            policy: this,\n          };\n        }\n        if (!response || !response.headers) {\n            throw Error('Response headers missing');\n        }\n\n        // These aren't going to be supported exactly, since one CachePolicy object\n        // doesn't know about all the other cached objects.\n        let matches = false;\n        if (response.status !== undefined && response.status != 304) {\n            matches = false;\n        } else if (\n            response.headers.etag &&\n            !/^\\s*W\\//.test(response.headers.etag)\n        ) {\n            // \"All of the stored responses with the same strong validator are selected.\n            // If none of the stored responses contain the same strong validator,\n            // then the cache MUST NOT use the new response to update any stored responses.\"\n            matches =\n                this._resHeaders.etag &&\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                    response.headers.etag;\n        } else if (this._resHeaders.etag && response.headers.etag) {\n            // \"If the new response contains a weak validator and that validator corresponds\n            // to one of the cache's stored responses,\n            // then the most recent of those matching stored responses is selected for update.\"\n            matches =\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                response.headers.etag.replace(/^\\s*W\\//, '');\n        } else if (this._resHeaders['last-modified']) {\n            matches =\n                this._resHeaders['last-modified'] ===\n                response.headers['last-modified'];\n        } else {\n            // If the new response does not include any form of validator (such as in the case where\n            // a client generates an If-Modified-Since request from a source other than the Last-Modified\n            // response header field), and there is only one stored response, and that stored response also\n            // lacks a validator, then that stored response is selected for update.\n            if (\n                !this._resHeaders.etag &&\n                !this._resHeaders['last-modified'] &&\n                !response.headers.etag &&\n                !response.headers['last-modified']\n            ) {\n                matches = true;\n            }\n        }\n\n        if (!matches) {\n            return {\n                policy: new this.constructor(request, response),\n                // Client receiving 304 without body, even if it's invalid/mismatched has no option\n                // but to reuse a cached body. We don't have a good way to tell clients to do\n                // error recovery in such case.\n                modified: response.status != 304,\n                matches: false,\n            };\n        }\n\n        // use other header fields provided in the 304 (Not Modified) response to replace all instances\n        // of the corresponding header fields in the stored response.\n        const headers = {};\n        for (const k in this._resHeaders) {\n            headers[k] =\n                k in response.headers && !excludedFromRevalidationUpdate[k]\n                    ? response.headers[k]\n                    : this._resHeaders[k];\n        }\n\n        const newResponse = Object.assign({}, response, {\n            status: this._status,\n            method: this._method,\n            headers,\n        });\n        return {\n            policy: new this.constructor(request, newResponse, {\n                shared: this._isShared,\n                cacheHeuristic: this._cacheHeuristic,\n                immutableMinTimeToLive: this._immutableMinTtl,\n            }),\n            modified: false,\n            matches: true,\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}